# Monorepo Shared Ledger System

Test project by SevenApps, a generic ledger system to be used by multiple apps in a monorepo implemented strictly with/as Enums and database interactions flowing through SQLAlchemy and Alembic into PostgreSQL.

---

### Quick overview of development

#### Base ledger and its inheritance

```python-repl

# core/ledgers/schemas.py
class BaseLedgerOperation(Enum):
    CREDIT = "CREDIT"        # Add credits
    DEBIT = "DEBIT"          # Subtract credits
    TRANSFER = "TRANSFER"    # Move credits between accounts

# /content/src/api/ledgers/schemas.py
class ContentLedgerOperation(BaseLedgerOperation, Enum):
    # BaseLedgerOperation ops are accessible by dot(.) operator.
    CONTENT_CREATION = "CONTENT_CREATION" # Spend credits to publish content
    CONTENT_ACCESS = "CONTENT_ACCESS"    # Adjust credits for accessing premium content

# /freelance/src/api/ledgers/schemas.py
class FreelancingLedgerOperation(BaseLedgerOperation, Enum):
    # BaseLedgerOperation ops are accessible by dot(.) operator.
    PROJECT_PAYMENT = "PROJECT_PAYMENT"  # Incoming payment for a project
    PROJECT_SPENDING = "PROJECT_SPENDING"  # Outgoing spending for a project

```

---

#### Database setup

From pgAdmin ledgers schema has ledger_entries(names completely optional) with the following fields:

![1738069224493](image/README/1738069224493.png)

Restriction of apps only interacting with their own entries on a shared table requires `app` field, `nonce` is used for its usual purpose and `related_ops` is a foreign key to id to link transaction-like operations that requires multiple entries to fully contextualize.

Here are some concerns:

- While the implementation of access to database prevents it, by nature every app connecting to this table has the same permissions and an attacker can leverage it to alter other app's entries.
- Generic and common implementation of ledger system is good for small scale systems with limited entries, but on prolonged use, for each app this table would be bloated with other apps entires, and harder to work with from an optimization perspective.
- On monorepos with small number of apps most of the `app` fields would be filled with same few default values, this can be streamlined by putting app prefix before every operation or better yet seperate app tables from each other so they dont have the previous two concerns either.

And none of these concerns are in the scope of this project but my thought process.

---

#### Database Interactions

Database definitions are provided in `core/ledgers/models.py` and its access is in `core/ledgers/repository.py` which is using generic database connection session in `core/database.py`.
Engine is imported from a private `config.py` file and its defined as:

```python-repl
# Construct Async Database URL
DATABASE_URL = (
    f"postgresql+asyncpg://{database.username}:{database.password}@"
    f"{database.host}:{database.port}/{database.database_name}"
)

# Create the Async SQLAlchemy Engine
engine = create_async_engine(DATABASE_URL, echo=True, future=True)
```

You can make your own `config.py` in root of monorepo. ## TODO: Should probably add `config_example.py` to public repo.

We also have `core/ledgers/schemas.py` for pydantic which is also one of the requirements. It is used in type defining in API calls.

#### Business logic

It is generally handled by `core/ledgers/service.py` and `core/ledgers/repository.py`.

#### API calls

FastAPI is used to simulate frontend service interactions. App is initialized in `core/main.py` and API endpoints for ledger system is in `core/ledgers/api_routes.py`.

---

#### Testing

The import of `core` funtionality conflicts with main python package/library `core` so I packaged the monorepo and served back to itself as library, it half worked and there are problems with paths most likely but I think it goes beyond the purpose and limits of this project so who cares.

---

#### Further Progress

While I am done with this, here is a list of shortcomings/TODOs:

- Never used SQLAlchemy before, so even if the code works, it was generated by AI and I dont know how it works in detail under the hood.
- Related Ops field defined in database is not implemented or enforced at any capacity in backend code, while it is only a utility I would have liked to have it.
- There are still some import problems with tests not being able to access certain core funtionality and according to most common case, this is a `__init__.py` problem and is fixed by adding or removing them from packaged folders. Exactly which folders and if its add or remove seems to be case based and I dont have time to play around with them. Be my guest.
- The concern of mixing tables in order to make everything generic is still quite a problem. A better solution than my simple one might be to have core ledger process the request but before committing to database it can evoke a supplied fuction of app-spesific ledger sending the processed data so that apps can specialize and refine their entries in the database. Not a perfect solution but slightly more elegant. The problem of identifying which entry belongs to which app is not solved by this approach however. Previously mentioned prefix method might tho.

---
